[ L
    ( Position 1 1 )
    ( Indent 0 )
, L
    ( Position 1 1 )
    ( TokSym "name" )
, L
    ( Position 1 5 ) Colon
, L
    ( Position 1 22 )
    ( TokSym "streaming-bytestring" )
, L
    ( Position 2 1 )
    ( Indent 0 )
, L
    ( Position 2 1 )
    ( TokSym "version" )
, L
    ( Position 2 8 ) Colon
, L
    ( Position 2 22 )
    ( TokSym "0.1.4.6" )
, L
    ( Position 3 1 )
    ( Indent 0 )
, L
    ( Position 3 1 )
    ( TokSym "synopsis" )
, L
    ( Position 3 9 ) Colon
, L
    ( Position 3 22 )
    ( TokSym "effectful" )
, L
    ( Position 3 32 )
    ( TokSym "byte" )
, L
    ( Position 3 37 )
    ( TokSym "steams" )
, L
    ( Position 3 43 )
    ( TokOther "," )
, L
    ( Position 3 45 )
    ( TokSym "or" )
, L
    ( Position 3 47 ) Colon
, L
    ( Position 3 49 )
    ( TokSym "bytestring" )
, L
    ( Position 3 60 )
    ( TokSym "io" )
, L
    ( Position 3 63 )
    ( TokSym "done" )
, L
    ( Position 3 68 )
    ( TokSym "right." )
, L
    ( Position 5 1 )
    ( Indent 0 )
, L
    ( Position 5 1 )
    ( TokSym "description" )
, L
    ( Position 5 12 ) Colon
, L
    ( Position 5 22 )
    ( TokSym "This" )
, L
    ( Position 5 27 )
    ( TokSym "is" )
, L
    ( Position 5 30 )
    ( TokSym "an" )
, L
    ( Position 5 33 )
    ( TokSym "implementation" )
, L
    ( Position 5 48 )
    ( TokSym "of" )
, L
    ( Position 5 51 )
    ( TokSym "effectful" )
, L
    ( Position 5 60 )
    ( TokOther "," )
, L
    ( Position 5 62 )
    ( TokSym "memory-constrained" )
, L
    ( Position 6 1 )
    ( Indent 21 )
, L
    ( Position 6 22 )
    ( TokSym "bytestrings" )
, L
    ( Position 6 34 )
    ( TokOther "(" )
, L
    ( Position 6 35 )
    ( TokSym "byte" )
, L
    ( Position 6 40 )
    ( TokSym "streams" )
, L
    ( Position 6 47 )
    ( TokOther ")" )
, L
    ( Position 6 49 )
    ( TokSym "and" )
, L
    ( Position 6 53 )
    ( TokSym "functions" )
, L
    ( Position 6 63 )
    ( TokSym "for" )
, L
    ( Position 6 67 )
    ( TokSym "streaming" )
, L
    ( Position 7 1 )
    ( Indent 21 )
, L
    ( Position 7 22 )
    ( TokSym "bytestring" )
, L
    ( Position 7 33 )
    ( TokSym "manipulation" )
, L
    ( Position 7 45 )
    ( TokOther "," )
, L
    ( Position 7 47 )
    ( TokSym "adequate" )
, L
    ( Position 7 56 )
    ( TokSym "for" )
, L
    ( Position 7 60 )
    ( TokSym "non-lazy-io." )
, L
    ( Position 8 1 )
    ( Indent 21 )
, L
    ( Position 8 22 )
    ( TokSym "." )
, L
    ( Position 9 1 )
    ( Indent 21 )
, L
    ( Position 9 22 )
    ( TokSym "The" )
, L
    ( Position 9 26 )
    ( TokSym "implementation" )
, L
    ( Position 9 41 )
    ( TokSym "follows" )
, L
    ( Position 9 49 )
    ( TokSym "the" )
, L
    ( Position 10 1 )
    ( Indent 21 )
, L
    ( Position 10 22 )
    ( TokSym "details" )
, L
    ( Position 10 30 )
    ( TokSym "of" )
, L
    ( Position 10 33 )
    ( TokOther "@" )
, L
    ( Position 10 34 )
    ( TokSym "Data.ByteString.Lazy" )
, L
    ( Position 10 54 )
    ( TokOther "@" )
, L
    ( Position 10 56 )
    ( TokSym "and" )
, L
    ( Position 10 60 )
    ( TokOther "@" )
, L
    ( Position 10 61 )
    ( TokSym "Data.ByteString.Lazy.Char8" )
, L
    ( Position 10 87 )
    ( TokOther "@" )
, L
    ( Position 11 1 )
    ( Indent 21 )
, L
    ( Position 11 22 )
    ( TokSym "in" )
, L
    ( Position 11 25 )
    ( TokSym "unrelenting" )
, L
    ( Position 11 37 )
    ( TokSym "detail" )
, L
    ( Position 11 43 )
    ( TokOther "," )
, L
    ( Position 11 45 )
    ( TokSym "omitting" )
, L
    ( Position 11 54 )
    ( TokSym "only" )
, L
    ( Position 11 59 )
    ( TokSym "transparently" )
, L
    ( Position 11 73 )
    ( TokSym "non-streaming" )
, L
    ( Position 12 1 )
    ( Indent 21 )
, L
    ( Position 12 22 )
    ( TokSym "operations" )
, L
    ( Position 12 33 )
    ( TokSym "like" )
, L
    ( Position 12 38 )
    ( TokOther "@" )
, L
    ( Position 12 39 )
    ( TokSym "reverse" )
, L
    ( Position 12 46 )
    ( TokOther "@." )
, L
    ( Position 12 49 )
    ( TokSym "It" )
, L
    ( Position 12 52 )
    ( TokSym "is" )
, L
    ( Position 12 55 )
    ( TokSym "just" )
, L
    ( Position 12 60 )
    ( TokSym "a" )
, L
    ( Position 12 62 )
    ( TokSym "question" )
, L
    ( Position 12 71 )
    ( TokSym "of" )
, L
    ( Position 12 74 )
    ( TokSym "replacing" )
, L
    ( Position 13 1 )
    ( Indent 21 )
, L
    ( Position 13 22 )
    ( TokSym "the" )
, L
    ( Position 13 26 )
    ( TokSym "lazy" )
, L
    ( Position 13 31 )
    ( TokSym "bytestring" )
, L
    ( Position 13 42 )
    ( TokSym "type" )
, L
    ( Position 13 46 ) Colon
, L
    ( Position 14 1 )
    ( Indent 21 )
, L
    ( Position 14 22 )
    ( TokSym "." )
, L
    ( Position 15 1 )
    ( Indent 21 )
, L
    ( Position 15 22 )
    ( TokOther ">" )
, L
    ( Position 15 24 )
    ( TokSym "data" )
, L
    ( Position 15 29 )
    ( TokSym "ByteString" )
, L
    ( Position 15 44 )
    ( TokOther "=" )
, L
    ( Position 15 46 )
    ( TokSym "Empty" )
, L
    ( Position 15 54 )
    ( TokOther "|" )
, L
    ( Position 15 56 )
    ( TokSym "Chunk" )
, L
    ( Position 15 62 )
    ( TokSym "Strict.ByteString" )
, L
    ( Position 15 80 )
    ( TokSym "ByteString" )
, L
    ( Position 16 1 )
    ( Indent 21 )
, L
    ( Position 16 22 )
    ( TokSym "." )
, L
    ( Position 17 1 )
    ( Indent 21 )
, L
    ( Position 17 22 )
    ( TokSym "with" )
, L
    ( Position 17 27 )
    ( TokSym "the" )
, L
    ( Position 17 31 )
    ( TokOther "/" )
, L
    ( Position 17 32 )
    ( TokSym "minimal" )
, L
    ( Position 17 39 )
    ( TokOther "/" )
, L
    ( Position 17 41 )
    ( TokSym "effectful" )
, L
    ( Position 17 51 )
    ( TokSym "variant" )
, L
    ( Position 17 58 ) Colon
, L
    ( Position 18 1 )
    ( Indent 21 )
, L
    ( Position 18 22 )
    ( TokSym "." )
, L
    ( Position 19 1 )
    ( Indent 21 )
, L
    ( Position 19 22 )
    ( TokOther ">" )
, L
    ( Position 19 24 )
    ( TokSym "data" )
, L
    ( Position 19 29 )
    ( TokSym "ByteString" )
, L
    ( Position 19 40 )
    ( TokSym "m" )
, L
    ( Position 19 42 )
    ( TokSym "r" )
, L
    ( Position 19 44 )
    ( TokOther "=" )
, L
    ( Position 19 46 )
    ( TokSym "Empty" )
, L
    ( Position 19 52 )
    ( TokSym "r" )
, L
    ( Position 19 54 )
    ( TokOther "|" )
, L
    ( Position 19 56 )
    ( TokSym "Chunk" )
, L
    ( Position 19 62 )
    ( TokSym "Strict.ByteString" )
, L
    ( Position 19 80 )
    ( TokOther "(" )
, L
    ( Position 19 81 )
    ( TokSym "ByteString" )
, L
    ( Position 19 92 )
    ( TokSym "m" )
, L
    ( Position 19 94 )
    ( TokSym "r" )
, L
    ( Position 19 95 )
    ( TokOther ")" )
, L
    ( Position 19 97 )
    ( TokOther "|" )
, L
    ( Position 19 99 )
    ( TokSym "Go" )
, L
    ( Position 19 102 )
    ( TokOther "(" )
, L
    ( Position 19 103 )
    ( TokSym "m" )
, L
    ( Position 19 105 )
    ( TokOther "(" )
, L
    ( Position 19 106 )
    ( TokSym "ByteString" )
, L
    ( Position 19 117 )
    ( TokSym "m" )
, L
    ( Position 19 119 )
    ( TokSym "r" )
, L
    ( Position 19 120 )
    ( TokOther ")" )
, L
    ( Position 19 121 )
    ( TokOther ")" )
, L
    ( Position 20 1 )
    ( Indent 21 )
, L
    ( Position 20 22 )
    ( TokSym "." )
, L
    ( Position 21 1 )
    ( Indent 21 )
, L
    ( Position 21 22 )
    ( TokOther "(" )
, L
    ( Position 21 23 )
    ( TokSym "Constructors" )
, L
    ( Position 21 36 )
    ( TokSym "are" )
, L
    ( Position 21 40 )
    ( TokSym "necessarily" )
, L
    ( Position 21 52 )
    ( TokSym "hidden" )
, L
    ( Position 21 59 )
    ( TokSym "in" )
, L
    ( Position 21 62 )
    ( TokSym "internal" )
, L
    ( Position 21 71 )
    ( TokSym "modules" )
, L
    ( Position 21 79 )
    ( TokSym "in" )
, L
    ( Position 21 82 )
    ( TokSym "both" )
, L
    ( Position 21 87 )
    ( TokSym "the" )
, L
    ( Position 21 91 )
    ( TokOther "@" )
, L
    ( Position 21 92 )
    ( TokSym "Lazy" )
, L
    ( Position 21 96 )
    ( TokOther "@" )
, L
    ( Position 21 98 )
    ( TokSym "and" )
, L
    ( Position 21 102 )
    ( TokSym "the" )
, L
    ( Position 21 106 )
    ( TokOther "@" )
, L
    ( Position 21 107 )
    ( TokSym "Streaming" )
, L
    ( Position 21 116 )
    ( TokOther "@." )
, L
    ( Position 21 118 )
    ( TokOther ")" )
, L
    ( Position 22 1 )
    ( Indent 21 )
, L
    ( Position 22 22 )
    ( TokSym "." )
, L
    ( Position 23 1 )
    ( Indent 21 )
, L
    ( Position 23 22 )
    ( TokSym "That's" )
, L
    ( Position 23 29 )
    ( TokSym "it." )
, L
    ( Position 23 33 )
    ( TokSym "As" )
, L
    ( Position 23 36 )
    ( TokSym "a" )
, L
    ( Position 23 38 )
    ( TokSym "lazy" )
, L
    ( Position 23 43 )
    ( TokSym "bytestring" )
, L
    ( Position 23 54 )
    ( TokSym "is" )
, L
    ( Position 23 57 )
    ( TokSym "implemented" )
, L
    ( Position 23 69 )
    ( TokSym "internally" )
, L
    ( Position 24 1 )
    ( Indent 21 )
, L
    ( Position 24 22 )
    ( TokSym "by" )
, L
    ( Position 24 25 )
    ( TokSym "a" )
, L
    ( Position 24 27 )
    ( TokSym "sort" )
, L
    ( Position 24 32 )
    ( TokSym "of" )
, L
    ( Position 24 35 )
    ( TokSym "list" )
, L
    ( Position 24 40 )
    ( TokSym "of" )
, L
    ( Position 24 43 )
    ( TokSym "strict" )
, L
    ( Position 24 50 )
    ( TokSym "bytestring" )
, L
    ( Position 24 61 )
    ( TokSym "chunks" )
, L
    ( Position 24 67 )
    ( TokOther "," )
, L
    ( Position 24 69 )
    ( TokSym "a" )
, L
    ( Position 24 71 )
    ( TokSym "streaming" )
, L
    ( Position 24 81 )
    ( TokSym "bytestring" )
, L
    ( Position 24 92 )
    ( TokSym "is" )
, L
    ( Position 25 1 )
    ( Indent 21 )
, L
    ( Position 25 22 )
    ( TokSym "simply" )
, L
    ( Position 25 29 )
    ( TokSym "implemented" )
, L
    ( Position 25 41 )
    ( TokSym "as" )
, L
    ( Position 25 44 )
    ( TokSym "a" )
, L
    ( Position 25 46 )
    ( TokOther "/" )
, L
    ( Position 25 47 )
    ( TokSym "producer" )
, L
    ( Position 25 55 )
    ( TokOther "/" )
, L
    ( Position 25 57 )
    ( TokSym "or" )
, L
    ( Position 25 60 )
    ( TokOther "/" )
, L
    ( Position 25 61 )
    ( TokSym "generator" )
, L
    ( Position 25 70 )
    ( TokOther "/" )
, L
    ( Position 25 72 )
    ( TokSym "of" )
, L
    ( Position 25 75 )
    ( TokSym "strict" )
, L
    ( Position 25 82 )
    ( TokSym "bytestring" )
, L
    ( Position 25 93 )
    ( TokSym "chunks." )
, L
    ( Position 26 1 )
    ( Indent 21 )
, L
    ( Position 26 22 )
    ( TokSym "Most" )
, L
    ( Position 26 27 )
    ( TokSym "operations" )
, L
    ( Position 26 38 )
    ( TokSym "are" )
, L
    ( Position 26 42 )
    ( TokSym "defined" )
, L
    ( Position 26 50 )
    ( TokSym "by" )
, L
    ( Position 26 53 )
    ( TokSym "simply" )
, L
    ( Position 26 60 )
    ( TokSym "adding" )
, L
    ( Position 26 67 )
    ( TokSym "a" )
, L
    ( Position 26 69 )
    ( TokSym "line" )
, L
    ( Position 26 74 )
    ( TokSym "to" )
, L
    ( Position 26 77 )
    ( TokSym "what" )
, L
    ( Position 26 82 )
    ( TokSym "we" )
, L
    ( Position 26 85 )
    ( TokSym "find" )
, L
    ( Position 26 90 )
    ( TokSym "in" )
, L
    ( Position 27 1 )
    ( Indent 21 )
, L
    ( Position 27 22 )
    ( TokOther "@" )
, L
    ( Position 27 23 )
    ( TokSym "Data.ByteString.Lazy" )
, L
    ( Position 27 43 )
    ( TokOther "@." )
, L
    ( Position 28 1 )
    ( Indent 21 )
, L
    ( Position 28 22 )
    ( TokSym "." )
, L
    ( Position 29 1 )
    ( Indent 21 )
, L
    ( Position 29 22 )
    ( TokSym "Something" )
, L
    ( Position 29 32 )
    ( TokSym "like" )
, L
    ( Position 29 37 )
    ( TokSym "this" )
, L
    ( Position 29 42 )
    ( TokSym "alteration" )
, L
    ( Position 29 53 )
    ( TokSym "of" )
, L
    ( Position 29 56 )
    ( TokSym "type" )
, L
    ( Position 29 61 )
    ( TokSym "is" )
, L
    ( Position 29 64 )
    ( TokSym "of" )
, L
    ( Position 29 67 )
    ( TokSym "course" )
, L
    ( Position 29 74 )
    ( TokSym "obvious" )
, L
    ( Position 29 82 )
    ( TokSym "and" )
, L
    ( Position 29 86 )
    ( TokSym "mechanical" )
, L
    ( Position 29 96 )
    ( TokOther "," )
, L
    ( Position 29 98 )
    ( TokSym "once" )
, L
    ( Position 29 103 )
    ( TokSym "the" )
, L
    ( Position 29 107 )
    ( TokSym "idea" )
, L
    ( Position 29 112 )
    ( TokSym "of" )
, L
    ( Position 30 1 )
    ( Indent 21 )
, L
    ( Position 30 22 )
    ( TokSym "an" )
, L
    ( Position 30 25 )
    ( TokSym "effectful" )
, L
    ( Position 30 35 )
    ( TokSym "bytestring" )
, L
    ( Position 30 46 )
    ( TokSym "type" )
, L
    ( Position 30 51 )
    ( TokSym "is" )
, L
    ( Position 30 54 )
    ( TokSym "contemplated" )
, L
    ( Position 30 67 )
    ( TokSym "and" )
, L
    ( Position 30 71 )
    ( TokSym "lazy" )
, L
    ( Position 30 76 )
    ( TokSym "io" )
, L
    ( Position 30 79 )
    ( TokSym "is" )
, L
    ( Position 30 82 )
    ( TokSym "rejected." )
, L
    ( Position 31 1 )
    ( Indent 21 )
, L
    ( Position 31 22 )
    ( TokSym "Indeed" )
, L
    ( Position 31 29 )
    ( TokSym "it" )
, L
    ( Position 31 32 )
    ( TokSym "seems" )
, L
    ( Position 31 38 )
    ( TokSym "that" )
, L
    ( Position 31 43 )
    ( TokSym "this" )
, L
    ( Position 31 48 )
    ( TokSym "is" )
, L
    ( Position 31 51 )
    ( TokSym "the" )
, L
    ( Position 31 55 )
    ( TokSym "proper" )
, L
    ( Position 31 62 )
    ( TokSym "expression" )
, L
    ( Position 31 73 )
    ( TokSym "of" )
, L
    ( Position 31 76 )
    ( TokSym "what" )
, L
    ( Position 31 81 )
    ( TokSym "was" )
, L
    ( Position 32 1 )
    ( Indent 21 )
, L
    ( Position 32 22 )
    ( TokSym "intended" )
, L
    ( Position 32 31 )
    ( TokSym "by" )
, L
    ( Position 32 34 )
    ( TokSym "lazy" )
, L
    ( Position 32 39 )
    ( TokSym "bytestrings" )
, L
    ( Position 32 51 )
    ( TokSym "to" )
, L
    ( Position 32 54 )
    ( TokSym "begin" )
, L
    ( Position 32 60 )
    ( TokSym "with." )
, L
    ( Position 32 66 )
    ( TokSym "The" )
, L
    ( Position 32 70 )
    ( TokSym "documentation" )
, L
    ( Position 32 83 )
    ( TokOther "," )
, L
    ( Position 32 85 )
    ( TokSym "after" )
, L
    ( Position 32 91 )
    ( TokSym "all" )
, L
    ( Position 32 94 )
    ( TokOther "," )
, L
    ( Position 33 1 )
    ( Indent 21 )
, L
    ( Position 33 22 )
    ( TokSym "reads" )
, L
    ( Position 34 1 )
    ( Indent 21 )
, L
    ( Position 34 22 )
    ( TokSym "." )
, L
    ( Position 35 1 )
    ( Indent 21 )
, L
    ( Position 35 22 )
    ( TokOther "*" )
, L
    ( Position 35 24 )
    ( TokOther "\" )
, L
    ( Position 35 96 )
    ( LexicalError "
                           unbounded streams of data without requiring the entire sequence to be 
                           resident in memory. To take advantage of this you have to write your 
                           functions in a lazy streaming style, e.g. classic pipeline composition. 
                           The default I/O chunk size is 32k, which should be good in most circumstances.\"
                         .
                         ... which is very much the idea of this library: the default chunk size for
                         'hGetContents' and the like follows @Data.ByteString.Lazy@; operations
                         like @lines@ and @append@ and so on are tailored not to increase chunk size. 
                         .
                         The present library is thus nothing but /lazy bytestring done right/. 
                         The authors of @Data.ByteString.Lazy@ must have supposed that 
                         the directly monadic formulation of such their type 
                         would necessarily make things slower. This appears to be a prejudice. 
                         For example, passing a large file of short lines through
                         this benchmark transformation
                         .
                         > Lazy.unlines      . map    (\bs -> "!"       <> Lazy.drop 5 bs)       . Lazy.lines
                         > Streaming.unlines . S.maps (\bs -> chunk "!" >> Streaming.drop 5 bs)  . Streaming.lines
                         .
                         gives pleasing results like these
                         .
                         > $  time ./benchlines lazy >> /dev/null
                         > real\x90m2.097s
                         > ...
                         > $  time ./benchlines streaming >> /dev/null
                         > real\x90m1.930s
                         .
                         For a more sophisticated operation like
                         .
                         > Lazy.intercalate "!\n"      . Lazy.lines
                         > Streaming.intercalate "!\n" . Streaming.lines
                         .
                         we get results like these:
                         .
                         > time ./benchlines lazy >> /dev/null
                         > real\x90m1.250s
                         > ...
                         > time ./benchlines streaming >> /dev/null
                         > real\x90m1.531s
                         . 
                         The pipes environment would express the latter as 
                         .
                         > Pipes.intercalates (Pipes.yield "!\n") . view Pipes.lines 
                         .
                         meaning almost exactly what we mean above, but with results like this
                         .
                         >  time ./benchlines pipes >> /dev/null
                         >  real\x90m6.353s
                         .
                         The difference, however, is emphatically not intrinsic to pipes; 
                         it is just that 
                         this library depends the @streaming@ library, which is used in place 
                         of @free@ to express the 
                         <http://www.haskellforall.com/2013/09/perfect-streaming-using-pipes-bytestring.html "perfectly streaming">
                         splitting and iterated division or "chunking" of byte streams. 
                         .
                         These concepts belong to the ABCs of streaming; @lines@ is just
                         a textbook example, and it is of course handled correctly in 
                         @Data.ByteString.Lazy@.
                         But the concepts are /catastrophically mishandled/ in /all/ streaming io libraries 
                         other than pipes. Already the @enumerator@ and @iteratee@ libraries
                         were completely defeated by @lines@: 
                         see e.g. the @enumerator@ implementation of 
                         <http://hackage.haskell.org/package/enumerator-0.4.20/docs/Data-Enumerator-Text.html#v:splitWhen splitWhen and lines>.
                         This will concatenate strict text forever, if that's what is coming
                         in.  The rot spreads from there. 
                         It is just a fact that in all of the general streaming io 
                         frameworks other than pipes,it becomes torture to express elementary distinctions 
                         that are transparently and immediately contained in any 
                         idea of streaming whatsoever. 
                         .
                         Though, as was said above, we barely alter signatures in @Data.ByteString.Lazy@ 
                         more than is required by the types, the point of view that emerges 
                         is very much that of
                         @pipes-bytestring@ and @pipes-group@. In particular
                         we have these correspondences:
                         .
                         > Lazy.splitAt      :: Int -> ByteString              -> (ByteString, ByteString)
                         > Streaming.splitAt :: Int -> ByteString m r          -> ByteString m (ByteString m r)
                         > Pipes.splitAt     :: Int -> Producer ByteString m r -> Producer ByteString m (Producer ByteString m r)
                         .
                         and
                         .
                         > Lazy.lines      :: ByteString -> [ByteString]
                         > Streaming.lines :: ByteString m r -> Stream (ByteString m) m r
                         > Pipes.lines     :: Producer ByteString m r -> FreeT (Producer ByteString m) m r
                         .
                         where the @Stream@ type expresses the sequencing of @ByteString m _@ layers
                         with the usual \'free monad\' sequencing. 
                         .
                         Interoperation with @pipes-bytestring@ uses this isomorphism:
                         . 
                         > Streaming.ByteString.unfoldrChunks Pipes.next :: Monad m => Producer ByteString m r -> ByteString m r
                         > Pipes.unfoldr Streaming.ByteString.nextChunk  :: Monad m => ByteString m r -> Producer ByteString m r
                         .
                         Interoperation with @io-streams@ is thus:
                         .
                         > IOStreams.unfoldM Streaming.ByteString.unconsChunk :: ByteString IO () -> IO (InputStream ByteString)
                         > Streaming.ByteString.reread IOStreams.read         :: InputStream ByteString -> ByteString IO ()
                         .
                         and similarly for other rational streaming io libraries. 
                         .
                         Problems and questions about the library can be put as issues on 
                         the github page, or mailed to the 
                         <https://groups.google.com/forum/#!forum/haskell-pipes pipes list>.
                         .
                         A tutorial module is in the works; 
                         <https://gist.github.com/michaelt/6c6843e6dd8030e95d58 here>,
                         for the moment, 
                         is a sequence of simplified implementations of familiar shell utilities.  
                         The same programs are implemented at the end of the excellent
                           <http://hackage.haskell.org/package/io-streams-1.3.2.0/docs/System-IO-Streams-Tutorial.html io-streams tutorial>.
                           It is generally much simpler; in some case simpler than what
                           you would write with lazy bytestrings. 
                           <https://gist.github.com/michaelt/2dcea1ba32562c091357 Here>
                           is a simple GET request that returns a byte stream.
                           .

                        
    license:             BSD3
    license-file:        LICENSE
    author:              michaelt
    maintainer:          what_is_it_to_do_anything@yahoo.com
    -- copyright:           
    category:            Data, Pipes, Streaming
    build-type:          Simple
    extra-source-files:  README.md
    cabal-version:       >=1.10
    stability:           Experimental
    homepage:            https://github.com/michaelt/streaming-bytestring
    bug-reports:         https://github.com/michaelt/streaming-bytestring/issues
    source-repository head
        type: git
        location: https://github.com/michaelt/streaming-bytestring


    library
      exposed-modules:     Data.ByteString.Streaming
                           , Data.ByteString.Streaming.Char8
                           , Data.ByteString.Streaming.Internal

                           
      -- other-modules:       
      other-extensions:    CPP, BangPatterns, ForeignFunctionInterface, DeriveDataTypeable, Unsafe
      build-depends:       base  <5.0
                         , deepseq 
                         , bytestring
                         , mtl >=2.1 && <2.3
                         , mmorph >=1.0 && <1.2
                         , transformers >=0.3 && <0.6
                         , transformers-base
                         , streaming >=  0.1.4.0 && < 0.1.4.8
                         , resourcet
                         , exceptions
      if impl(ghc < 7.8) 
        build-depends:
                         bytestring < 0.10.4.0
                         , bytestring-builder
      else               
        build-depends:     
                         bytestring >= 0.10.4                     


      default-language:    Haskell2010
      ghc-options: -O2
      
    test-suite test
      default-language:
        Haskell2010
      type:
        exitcode-stdio-1.0
      hs-source-dirs:
        tests
      main-is:
        test.hs
      build-depends:
          base >= 4 && < 5
        , transformers
        , tasty >= 0.11.0.4
        , tasty-smallcheck >= 0.8.1
        , smallcheck >= 1.1.1
        , streaming
        , streaming-bytestring
        , bytestring
    " )
, L
    ( Position 35 25 ) EOF
]
